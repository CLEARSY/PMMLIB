/******************************* CLEARSY **************************************
This file is part of PMMLIB
    Copyright Â© CLEARSY 2008-2020 (contact@clearsy.com)

    PMMLIB is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; GNU General Public License version 3
    of the License

    PMMLIB is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with PMMLIB; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
******************************************************************************/
#ifndef BAST_H_
#define BAST_H_
#include <iostream>
#include <string>
#include <vector>
#include "TextPos.h"
namespace theory
{
/**
 * The default types for nodes
 */
typedef enum NodeType
{
	NODE_UNARY_OPERATOR,
	NODE_BINARY_OPERATOR,
	NODE_IDENT,
	NODE_JOKER,
	NODE_INTEGER_LITERAL,
    NODE_REAL_LITERAL,
	NODE_STRING_LITERAL,
	NODE_OTHER,

	NODE_FREE
} NodeType;

class NodeWriter;
class NodeAttribute;
class JokerInstanciation;

/**
 * A common class for the B Abstract Syntax Trees that are
 * generated by the parser
 */
class BNode
{
private:
	int type;
	/**
	 * The sibling AST in the tree
	 */
	BNode *sibling;
	/**
	 * The value of the AST
	 */
	std::string value;

        TextPos pos;

        NodeAttribute *attributes;

	static int nextFreeType;

        /**
         * Updates the given range with the range of the given node
         */
        void mergeRange(TextPos& start, TextPos& end);
public:
	BNode(int type=NODE_OTHER);
	BNode(int type, const std::string& val);
	/**
	 * Returns a copy of the current node and all its childrens.
	 * The sibling nodes are not copied
	 *
	 * @param n the node to copy
	 */
	BNode(const BNode&n);

	/**
	 * Deletes the current AST. This function also deletes
	 * all the childrens and sibling of the current AST
	 */
	virtual ~BNode();

        void addAttribute(NodeAttribute *attr);
        void setAttribute(NodeAttribute *attr);

        NodeAttribute *getAttribute(const std::string& attribute_name) const;
        void removeAttribute(const std::string& attribute_name);

	inline int getType() const { return type; }

	inline const std::string& getValue() const { return value; }

	inline const BNode *getSibling() const { return sibling; }
	inline BNode *getSibling() { return sibling; }
	/**
	 * Sets the new sibling for the current AST
	 *
	 * @param new_sibling the new sibling
	 * @return the new sibling (new_sibling)
	 */
	BNode *setSibling(BNode *new_sibling);

	virtual const BNode *getChild() const;
	virtual  BNode *getChild();


	/**
	 * Sets the new child for the current AST
	 * @param new_child the new child
	 * @return the new child, or NULL if the set failed
	 *    (for instance if the node cannot have children)
	 */
	virtual BNode *setChild(BNode *new_child);

	void setValue(const std::string& new_value) { value = new_value; }

	virtual void writeTo(NodeWriter& n) const = 0;

	/**
	 * Returns a copy of the current AST tree. This method
	 * should be overriden in all subclasses of BAST to ensure
	 * that no information is lost during the copy.
	 *
	 * @return a copy of the current ast
	 */
	virtual BNode *copy() const = 0;

	/**
	 * Returns a new type identifier for a new node type
	 *
	 * @return a new type suitable for creating nodes
	 */
	static int getNewType();

	/**
	 * Compares the current node and its children to the
	 * given node
	 *
	 * @param other the other node
	 * @return true if the trees are equal, false otherwise
	 */
	virtual bool compare(const BNode*other) const;

	/**
	 * Compares the content of the current node with the
	 * other given node.
	 * This method only compares the content of the node,
	 * and do not compare the content of the children nodes.
	 *
	 * The default implementation considers that the nodes
	 * are equals if they have the same type and value
	 *
	 * @param other the other node
	 * @return true if the nodes are equals, false otherwise
	 */
	virtual bool compareNode(const BNode *other) const;

    static const int MaxPriority = 65000;

	/**
	 * Returns the priority of the current node. This priority
	 * is used to display or not display parenthesis.
	 *
	 * @return the priority of the operator
	 */
	virtual int getPriority() const;

        /**
         * Returns a copy of the current node, where instanciated
         * jokers are replaced by their instanciation
         *
         * @param j the instanciation
         * @return a copy of the current node, with jokers replaced by
         *   their instanciation
         */
        virtual BNode *instanciatedCopy(const JokerInstanciation*j) const;

	/**
	 * Find the occurences of a given node in the current node
	 * @param other the given node
	 * @return the occurences
	 */
	int occurence(const BNode *other) const;

	/**
	   @brief tests if nodes are sub-terms

	   @return true iff one of the others is a sub-term of this
	*/
	bool find(const std::vector< const BNode* >& others) const;

    /**
     * @brief depth
     * @return size of the longest one-way path from root to leaf
     * @note 0 for single-node terms
     * @note linear complexity
     */
    int depth() const;

        int getLine() const { return pos.getLine(); }
        int getColumn() const { return pos.getColumn(); }

        void setPosition(int l, int c)     { pos.setPos(l, c); }
        void setPosition(const TextPos &p) { pos = p; }
        /**
         * Return the range of text that is taken by the current node,
         * not including its children nodes.
         *
         * @param start The starting position of the text
         * @param end   The ending position of the text
         */
        void getTokenRange(TextPos& start, TextPos& end);

        /**
         * Return the range of text that is taken by the given node and
         * its children nodes
         *
         * @param start The starting position
         * @param end   The end position
         */
        void getRange(TextPos& start, TextPos& end);
};


std::ostream& operator<< (std::ostream& o, const theory::BNode&b);
}
#endif /*BAST_H_*/
